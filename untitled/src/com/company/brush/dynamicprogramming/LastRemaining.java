/**
 * @author: Wxj
 * 剑指 Offer 62. 圆圈中最后剩下的数字
 * 0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。
 * 求出这个圆圈里剩下的最后一个数字。
 * 例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。
 * <p>输入描述:
 * n = 5, m = 3
 * <p>输出描述:
 * 3
 */
package com.company.brush.dynamicprogramming;

// 对于[n, m]问题，首轮删除环中第 m 个数字后，得到一个长度为 n - 1 的数字环。
// 由于有可能 m > n ，因此删除的数字为 (m - 1) % n ，
// 删除后的数字环从下个数字（即 m % n）开始，设 t = m % n ，可得数字环：
// t, t + 1, t + 2, ..., 0, 1, ..., t - 3, t - 2
// 此时，数字环也变为一个[n-1, m]问题，位置后移了 t 个。
// f(n)=(f(n−1)+t)%n
//     =(f(n−1)+m%n)%n
//     =(f(n−1)+m)%n
// 定理一：两个正整数a，b的和，模另外一个数c，就等于它俩分别模c，模完之后加起来再模。
// (a+b)%c=((a%c)+(b%c))%c
// 定理二：一个正整数a，模c，模一遍和模两遍是一样的。
// a%c=(a%c)%c
public class LastRemaining {
    public int solution(int n, int m) {
        // 维护一个变量表示状态转移
        // 初始条件为 0 （n = 1）
        int x = 0;
        for (int i = 2; i <= n; i++) {
            x = (x + m) % i;
        }
        return x;
    }
}
